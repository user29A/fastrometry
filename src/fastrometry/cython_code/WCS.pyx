import scipy.optimize as optimization
import numpy as np
import sys
from pathlib import Path

cimport numpy as np
from libc.math cimport sin, cos, pi, asin, acos, atan, atan2, sqrt, abs

def printEvent(f):
    """
    A decorator function that causes messages to be printed to the print both before and after
    a process (for a total of two lines) if the verbosity is at the required level.
    The purpose of a decorator is to return a wrapper, which itself supplements the original
    function with additional commands.
    """
    def wrapper(*args, printconsole=None, **kwargs):
        startmessage = printconsole[0]
        endmessage = printconsole[1]
        verbosity = printconsole[2]
        levelneeded = printconsole[3]
        if verbosity >= levelneeded:
            print(startmessage)
        fout = f(*args,**kwargs)
        if verbosity >= levelneeded:
            print(endmessage)
        return fout
    return wrapper

def insertCopyNumber(outfilename, filename_body):
    copynum = 1
    while Path(outfilename).is_file():
        outfilename = filename_body+' WCS ({}) diagnostic.csv'.format(copynum)
        copynum += 1
    return outfilename

cdef getSkyCoordsFromPix(double[:,:] pixelpoints_view, int num_pixpoints, double[:] refined_solution_view, double[:] mean_catcoords_view, double[:,:] skypoints_view):
    
    """
    This function transforms any point (x,y) in the original image into sky coordinates IN RADIANS, using the solution
    generated by the WCS solver. First, the pixel coordinates are transformed into intermediate coordinates, and then
    those are inverse-Gnomonically projected onto the sky (the reverse of the procedure that was used to find the initial
    WCS solution).
    """

    cdef:
        double CD1_1 = refined_solution_view[0]
        double CD1_2 = refined_solution_view[1]
        double CD2_1 = refined_solution_view[2]
        double CD2_2 = refined_solution_view[3]
        double CRPIX1 = refined_solution_view[4]
        double CRPIX2 = refined_solution_view[5]
        double a0 = mean_catcoords_view[0]
        double d0 = mean_catcoords_view[1]
        double x
        double y
        double X
        double Y
        double p
        double c
        Py_ssize_t i

    #The inverse gnomonic equations from the paper (eqs. 3) have an error in the equation for the declination. They are given below.
    #skypoints_view[i,0] = a0 + atan2(X,cos(d0)-Y*sin(d0))
    #skypoints_view[i,1] = asin(sin(d0)+Y*cos(d0))/sqrt(1+X*X+Y*Y)
    #Here we use an alternate set of formulas from https://mathworld.wolfram.com/GnomonicProjection.html.

    for i in range(num_pixpoints):
        x = pixelpoints_view[i,0]
        y = pixelpoints_view[i,1]
        X = CD1_1*(x-CRPIX1) + CD1_2*(y-CRPIX2)
        Y = CD2_1*(x-CRPIX1) + CD2_2*(y-CRPIX2)

        p = sqrt(X*X+Y*Y)
        c = atan(p)
        skypoints_view[i,0] = a0 + atan2(X*sin(c),p*cos(d0)*cos(c)-Y*sin(d0)*sin(c))
        skypoints_view[i,1] = asin(cos(c)*sin(d0)+Y*sin(c)*cos(d0)/p)

cdef calculateWCSdiagnostics(int img_xmax, int img_ymax, double[:] refined_solution_view, double[:,:] matchdata_view, int matches, int num_catsources, double[:,:] catalogue_points_view, double[:] mean_catcoords_view, double[:] wcs_diagnostics_view, debug_report, debug):

    cdef:
        double centx = int(img_xmax/2)
        double centy = int(img_ymax/2)
        double[:,:] pixelpoint_center_view = np.array([[centx,centy]])
        double[:,:] skypoint_center_view = np.zeros((1,2))
        double[:,:] skypoints_matches_view = np.zeros((matches,2))
        double[:] residuals_ra = np.zeros(matches)
        double[:] residuals_dec = np.zeros(matches)
        double CCVALD1
        double CCVALD2
        double CCVALS1_h
        double CCVALS1_m
        double CCVALS1_s
        double CCVALS2_h
        double CCVALS2_m
        double CCVALS2_s
        double CVAL1RM
        double CVAL2RM
        double CVALRM
        double CVAL1RS
        double CVAL2RS
        double CVALRS
        Py_ssize_t i
        Py_ssize_t j

    getSkyCoordsFromPix(pixelpoint_center_view, 1, refined_solution_view, mean_catcoords_view, skypoint_center_view)

    CCVALD1 = skypoint_center_view[0,0]
    CCVALD2 = skypoint_center_view[0,1]

    dhours1 = CCVALD1*180/pi/15
    hours1 = int(dhours1)
    dminutes1 = (dhours1 - hours1)*60
    minutes1 = int(dminutes1)
    dseconds1 = (dminutes1 - minutes1)*60
    dhours2 = abs(CCVALD2)/15*180/pi/15
    hours2 = int(dhours2)
    dminutes2 = (dhours2 - hours2)*60
    minutes2 = int(dminutes2)
    dseconds2 = (dminutes2 - minutes2)*60
    if CCVALD2 < 0:
        hours2 *= -1

    CCVALS1_h = hours1 
    CCVALS1_m = minutes1
    CCVALS1_s = dseconds1
    CCVALS2_h = hours2 
    CCVALS2_m = minutes2
    CCVALS2_s = dseconds2

    getSkyCoordsFromPix(matchdata_view[:,3:5], matches, refined_solution_view, mean_catcoords_view, skypoints_matches_view)

    if debug:
        np.savetxt(debug_report/"skypoints_matches_view.csv", np.asarray(skypoints_matches_view), delimiter=",")

    for j in range(matches):
        matchdata_view[j,6] = catalogue_points_view[int(matchdata_view[j,2]),0]
        matchdata_view[j,7] = catalogue_points_view[int(matchdata_view[j,2]),1]
        residuals_ra[j] = (skypoints_matches_view[j,0] - matchdata_view[j,6])*180/pi*3600
        residuals_dec[j] = (skypoints_matches_view[j,1] - matchdata_view[j,7])*180/pi*3600
        matchdata_view[j,8] = residuals_ra[j]
        matchdata_view[j,9] = residuals_dec[j]

    if debug:
        np.savetxt(debug_report/"matchdata_wcsdiagnostic.csv", np.asarray(matchdata_view), delimiter=",")

    CVAL1RM = np.mean(residuals_ra)
    CVAL2RM = np.mean(residuals_dec)
    CVALRM = sqrt(CVAL1RM*CVAL1RM+CVAL2RM*CVAL2RM)

    CVAL1RS = np.std(residuals_ra)
    CVAL2RS = np.std(residuals_dec)
    CVALRS = sqrt(CVAL1RS*CVAL1RS+CVAL2RS*CVAL2RS)
    
    wcs_diagnostics_view[0] = CCVALD1
    wcs_diagnostics_view[1] = CCVALD2
    wcs_diagnostics_view[2] = CCVALS1_h
    wcs_diagnostics_view[3] = CCVALS1_m
    wcs_diagnostics_view[4] = CCVALS1_s
    wcs_diagnostics_view[5] = CCVALS2_h
    wcs_diagnostics_view[6] = CCVALS2_m
    wcs_diagnostics_view[7] = CCVALS2_s
    wcs_diagnostics_view[8] = CVAL1RM
    wcs_diagnostics_view[9] = CVAL1RS
    wcs_diagnostics_view[10] = CVAL2RM
    wcs_diagnostics_view[11] = CVAL2RS
    wcs_diagnostics_view[12] = CVALRM
    wcs_diagnostics_view[13] = CVALRS

def inverseTransformPointUsingCD(CD11, CD12, CD21, CD22, CRPIXx, CRPIXy, intrmx, intrmy, invtransf_intrmpoint_view):
    
    """
    Use the 4 CD matrix elements and the 2 CRPIX reference coordinates to inverse-transform individual intermediate points.
    """

    determinant = CD11*CD22-CD12*CD21
    CD11inv = 1/determinant*CD22
    CD12inv = -1/determinant*CD12
    CD21inv = -1/determinant*CD21
    CD22inv = 1/determinant*CD11
    invtransf_intrmpoint_view[0] = CRPIXx + CD11inv*intrmx + CD12inv*intrmy
    invtransf_intrmpoint_view[1] = CRPIXy + CD21inv*intrmx + CD22inv*intrmy

def fitNrefineptsToGetCD(params, matchdata, matches):
    """
    The optimizer function, for which the CD matrix and the CRPIX point are the parameters. After many runs of this function, the optimizer
    will settle on the CD elements and CRPIX coordinates which minimize the Nrefinepts residuals. Each residual is the difference between the forward-
    transformed pse coordinate and the intermediate coordinate that should result.
    """

    CD11 = params[0]
    CD12 = params[1]
    CD21 = params[2]
    CD22 = params[3]
    CRPIXx = params[4]
    CRPIXy = params[5]

    residuals = np.zeros(matches*2)

    for m in range(matches):
        intrmx = matchdata[m,0]
        intrmy = matchdata[m,1]
        psex = matchdata[m,3]
        psey = matchdata[m,4]
        residuals[2*m] = (CD11*(psex-CRPIXx) + CD12*(psey-CRPIXy)) - intrmx
        residuals[2*m+1] = (CD21*(psex-CRPIXx) + CD22*(psey-CRPIXy)) - intrmy

    return residuals

cdef int refineSolution(double[:,:] allintrmpoints_view, int num_catsources, double[:,:] pse_metadata_view, double[:,:] pse_metadata_inv_view, int num_psesources, double[:,:] matchdata_view, int[:] num_matches_view, int npts, int nrefinepts, int img_xmax, int img_ymax, int[:,:] srcindexmap_refine_view, double[:] initial_solution_view, double[:] refined_solution_view, debug_report, filepath, int verbosity, int debug):
    
    """
    Test previous solution using as many points as possible (all num_psesources points from the PSE and all num_catsources points from the catalogue).
    Instead of optimizing the parameters S, phi, CRPIXx and CRPIXy, simply optimize the individual matrix elements (labelled CD11, CD12, CD21, and CD22).
    Since the matrix elements no longer depend on each other, this allows for some skew in the inverse-transformation. Therefore if the image has skew, it
    will be captured in the optimizer solution (which consists of the parameters CD11, CD12, CD21, CD22, CRPIXx, CRPIXy). 
    """

    cdef:
        int nrefinepts_intrm
        int nrefinepts_pse
        int resultcode = 0

    #As mentioned before, it's possible (but rare) that the PSE output or the catalogue output may contain
    #less than npts in total. If this is the case, all possible points (for one or both of them) have already 
    #been tested in the initial solution. So using "all" test points would do nothing new (if both are less
    #than ntps) or increase only one set, which is not beneficial since we are looking for new intermediate 
    #points that land on new pse points. In this unfortunate circumstance we terminate the function by returning
    #a result code of 2.

    if num_catsources < npts or num_psesources < npts:
        resultcode = 2
        return resultcode
    else:
        nrefinepts_intrm = num_catsources
        nrefinepts_pse = num_psesources

    cdef:
        double S = initial_solution_view[0]
        double phi = initial_solution_view[1]
        double CRPIXx = initial_solution_view[2]
        double CRPIXy = initial_solution_view[3]
        double[:,:] psepoints_view = pse_metadata_view[:nrefinepts_pse,:2]
        double[:,:] psepoints_inv_view = pse_metadata_inv_view[:nrefinepts_pse,:2]
        double[:,:] intrmpoints_view = allintrmpoints_view[:nrefinepts_intrm,:]
        double CD11
        double CD11_guess = S*cos(phi)
        double CD12
        double CD12_guess = -S*sin(phi)
        double CD21
        double CD21_guess = S*sin(phi)
        double CD22
        double CD22_guess = S*cos(phi)
        double CRPIXx_guess = CRPIXx
        double CRPIXy_guess = CRPIXy
        double[:] invtransf_intrmpoint_view = np.empty(2,dtype=np.double)
        Py_ssize_t k
        Py_ssize_t m
        int src_ind
        int matches = 0

    if verbosity >= 1:
        print("| | (working with {} PSE sources and {} catalogue sources.)".format(nrefinepts_pse,nrefinepts_intrm))
        print("| | Applying initial solution to the larger dataset...")

    if debug:
        invtransf_xs = []
        invtransf_ys = []
        invtransf_match_xs = []
        invtransf_match_ys = []
    for k in range(nrefinepts_intrm):
        inverseTransformPointUsingSphi(S, phi, CRPIXx, CRPIXy, intrmpoints_view[k,0], intrmpoints_view[k,1], invtransf_intrmpoint_view)
        if debug:
            invtransf_xs.append(invtransf_intrmpoint_view[0])
            invtransf_ys.append(invtransf_intrmpoint_view[1])
        if 1 <= invtransf_intrmpoint_view[0] <= img_xmax and 1 <= invtransf_intrmpoint_view[1] <= img_ymax:
            src_ind = srcindexmap_refine_view[img_ymax-int(invtransf_intrmpoint_view[1])-1, img_xmax-int(invtransf_intrmpoint_view[0])-1]
            if src_ind != -1:
                matchdata_view[matches,0] = intrmpoints_view[k,0]           #An intermediate coordinate that inverse-transforms onto a source index, X coordinate
                matchdata_view[matches,1] = intrmpoints_view[k,1]           #An intermediate coordinate that inverse-transforms onto a source index, Y coordinate
                matchdata_view[matches,2] = k                               #The index of the intermediate coordinate in the allintrmcoords
                matchdata_view[matches,3] = psepoints_view[src_ind,0]       #The pse point which is landed on by inverse-transforming the intermediate point, x coordinate
                matchdata_view[matches,4] = psepoints_view[src_ind,1]       #The pse point which is landed on by inverse-transforming the intermediate point, y coordinate
                matchdata_view[matches,5] = src_ind                         #The index of the pse point in the pse_metadata
                matches += 1
                if debug:
                    invtransf_match_xs.append(invtransf_intrmpoint_view[0])
                    invtransf_match_ys.append(invtransf_intrmpoint_view[1])

    if debug:
        np.savetxt(debug_report/"matchdata_initial_{}.csv".format(nrefinepts_intrm),np.asarray(matchdata_view), delimiter=",")

    if verbosity >= 1:
        print("| | | Found {} matches.".format(matches))
    
    if debug:
        import matplotlib.pyplot as plt
        from matplotlib.colors import LogNorm
        from astropy.io import fits
        image_data = fits.getdata(filepath)
        fig = plt.figure(figsize=(9.5,8))

        axes = fig.add_subplot(111)
        axes.imshow(image_data, cmap="gray", norm=LogNorm())
        #axes.scatter(img_xmax-np.asarray(invtransf_match_xs), img_ymax-np.asarray(invtransf_match_ys), marker="o", color='white')
        axes.scatter(np.asarray(psepoints_view[:,0]), np.asarray(psepoints_view[:,1]), marker="+", color='yellow')
        axes.scatter(img_xmax-np.asarray(invtransf_xs), img_ymax-np.asarray(invtransf_ys), marker='.', color='fuchsia')
        
        dscrp = "Plot of the inverse-transformed points (fuchsia) of all {} intermediate points. The inverse \ntransform used here is made up of the parameters that were found in the initial solution. The \ninverse-transformed points that yield a match (i.e., those that land on an occupied kernel \nin the source index map) are highlighted with a white circle. The PSE points are in blue.".format(nrefinepts_intrm)
        plt.title("Inverse transform - {} points - initial solution".format(nrefinepts_intrm))
        plt.figtext(0.5, 0.05, dscrp, ha="center", fontsize=9)
        plt.subplots_adjust(top=0.92, bottom=0.2, right=0.92, left=0.08)
        plt.savefig(debug_report/"inversetrans_matches_initial_{}.png".format(nrefinepts_intrm))
        plt.show()
    
    if verbosity >= 1:
        print("| | done")
        print("| | Optimizing solution using the larger dataset...")

    guess = np.array([CD11_guess, CD12_guess, CD21_guess, CD22_guess, CRPIXx_guess, CRPIXy_guess])

    if verbosity == 2:
        print("| | CD1_1_guess = {}".format(CD11_guess))
        print("| | CD1_2_guess = {}".format(CD12_guess))
        print("| | CD2_1_guess = {}".format(CD21_guess))
        print("| | CD2_2_guess = {}".format(CD22_guess))
        print("| | CRPIXx_guess = {}".format(CRPIXx_guess))
        print("| | CRPIXy_guess = {}".format(CRPIXy_guess))
    
    optimizedparams = optimization.least_squares(fun=fitNrefineptsToGetCD, x0=guess, x_scale=[1e-6, 1e-6, 1e-6, 1e-6, CRPIXx_guess, CRPIXy_guess], args=(np.asarray(matchdata_view), matches))
    CD11 = optimizedparams.x[0]
    CD12 = optimizedparams.x[1]
    CD21 = optimizedparams.x[2]
    CD22 = optimizedparams.x[3]
    CRPIXx = optimizedparams.x[4]
    CRPIXy = optimizedparams.x[5]
    refined_solution_view[0] = CD11
    refined_solution_view[1] = CD12
    refined_solution_view[2] = CD21
    refined_solution_view[3] = CD22
    refined_solution_view[4] = CRPIXx
    refined_solution_view[5] = CRPIXy

    if verbosity >= 1:
        print("| | done")
        print("| | Refined solution vector: {}".format(np.asarray(refined_solution_view)))
    
    if verbosity == 2:
        print("| | * CD1_1: {}".format(CD11))
        print("| | * CD1_2: {}".format(CD12))
        print("| | * CD2_1: {}".format(CD21))
        print("| | * CD2_2: {}".format(CD22))
        print("| | * CRPIX1: {}".format(CRPIXx))
        print("| | * CRPIX2: {}".format(CRPIXy))
    
    if verbosity >= 1:
        print("| | Applying refined solution to the larger dataset...")

    matches = 0
    matchdata_view[:] = 0
    if debug:
        invtransf_xs = []
        invtransf_ys = []
        invtransf_match_xs = []
        invtransf_match_ys = []
    for k in range(nrefinepts_intrm):
        inverseTransformPointUsingCD(CD11, CD12, CD21, CD22, CRPIXx, CRPIXy, intrmpoints_view[k,0], intrmpoints_view[k,1], invtransf_intrmpoint_view)
        if debug:
            invtransf_xs.append(invtransf_intrmpoint_view[0])
            invtransf_ys.append(invtransf_intrmpoint_view[1])
        if 1 <= invtransf_intrmpoint_view[0] <= img_xmax and 1 <= invtransf_intrmpoint_view[1] <= img_ymax:
            src_ind = srcindexmap_refine_view[int(invtransf_intrmpoint_view[1])-1,int(invtransf_intrmpoint_view[0])-1]
            if src_ind != -1:
                matchdata_view[matches,0] = intrmpoints_view[k,0]           #An intermediate coordinate that inverse-transforms onto a source index, X coordinate
                matchdata_view[matches,1] = intrmpoints_view[k,1]           #An intermediate coordinate that inverse-transforms onto a source index, Y coordinate
                matchdata_view[matches,2] = k                               #The index of the intermediate coordinate in the allintrmcoords
                matchdata_view[matches,3] = psepoints_view[src_ind,0]       #The pse point which is landed on by inverse-transforming the intermediate point, x coordinate
                matchdata_view[matches,4] = psepoints_view[src_ind,1]       #The pse point which is landed on by inverse-transforming the intermediate point, y coordinate
                matchdata_view[matches,5] = src_ind                         #The index of the pse point in the pse_metadata
                matches += 1
                if debug:
                    invtransf_match_xs.append(invtransf_intrmpoint_view[0])
                    invtransf_match_ys.append(invtransf_intrmpoint_view[1])

    if debug:
        np.savetxt(debug_report/"matchdata_refine_{}.csv".format(nrefinepts_intrm),np.asarray(matchdata_view), delimiter=",")

    num_matches_view[0] = matches
    if verbosity >= 1:
        print("| | | Found {} matches.".format(matches))   
    
    if debug:
        import matplotlib.pyplot as plt
        from matplotlib.colors import LogNorm
        from astropy.io import fits
        image_data = fits.getdata(filepath)
        fig = plt.figure(figsize=(9.5,8))

        axes = fig.add_subplot(111)
        axes.imshow(image_data, cmap="gray", norm=LogNorm())
        #axes.scatter(invtransf_match_xs, invtransf_match_ys, marker="o", color='white')
        axes.scatter(np.asarray(psepoints_view[:,0]), np.asarray(psepoints_view[:,1]), marker="+", color='yellow')
        axes.scatter(invtransf_xs, invtransf_ys, c='fuchsia', marker='.')

        dscrp = "Plot of the inverse-transformed points (fuchsia) of all {} intermediate points. The inverse \ntransform used here is made up of the CD matrix elements that were found when refining \n(optimizing) the previous solution. The inverse-transformed points that yield a match (i.e., \nthose that land on an occupied kernel in the source index map) are highlighted with a white \ncircle. The PSE points are in blue.".format(nrefinepts_intrm)
        plt.title("Inverse transform - {} points - refined solution".format(nrefinepts_intrm))
        plt.figtext(0.5, 0.05, dscrp, ha="center", fontsize=9)
        plt.subplots_adjust(top=0.92, bottom=0.2, right=0.92, left=0.08)
        plt.savefig(debug_report/"inversetrans_matches_refine_{}.png".format(nrefinepts_intrm))
        plt.show()

    if verbosity >= 1:
        print("| | done")

    resultcode = 1
    return resultcode

cdef inverseTransformPointUsingSphi(double S, double phi, double CRPIXx, double CRPIXy, double intrmx, double intrmy, double[:] invtransf_intrmpoint_view):
    """
    Use S, phi and the 2 CRPIX reference coordinates to inverse-transform individual intermediate points.
    """

    invtransf_intrmpoint_view[0] = CRPIXx + (intrmx*cos(phi) + intrmy*sin(phi))/S
    invtransf_intrmpoint_view[1] = CRPIXy + (-intrmx*sin(phi) + intrmy*cos(phi))/S     

cdef inverseTransformTriangleUsingSphi(double S, double phi, double CRPIXx, double CRPIXy, double intrmAx, double intrmAy, double intrmBx, double intrmBy, double intrmCx, double intrmCy, double[:,:] invtransf_intrmtriangle_view):
    """
    Use S, phi and the 2 CRPIX reference coordinates to inverse-transform intermediate triangles (triplets of intermediate points).
    """

    invtransf_intrmtriangle_view[0,0] = CRPIXx + (intrmAx*cos(phi) + intrmAy*sin(phi))/S
    invtransf_intrmtriangle_view[0,1] = CRPIXy + (-intrmAx*sin(phi) + intrmAy*cos(phi))/S
    invtransf_intrmtriangle_view[1,0] = CRPIXx + (intrmBx*cos(phi) + intrmBy*sin(phi))/S
    invtransf_intrmtriangle_view[1,1] = CRPIXy + (-intrmBx*sin(phi) + intrmBy*cos(phi))/S
    invtransf_intrmtriangle_view[2,0] = CRPIXx + (intrmCx*cos(phi) + intrmCy*sin(phi))/S
    invtransf_intrmtriangle_view[2,1] = CRPIXy + (-intrmCx*sin(phi) + intrmCy*cos(phi))/S

def fitTrianglesToGetSphi(params, pseAx, pseAy, pseBx, pseBy, pseCx, pseCy, intrmAx, intrmAy, intrmBx, intrmBy, intrmCx, intrmCy):
    """
    The optimizer function, for which S, phi, CRPIXx and CRPIXy are the parameters. After many runs of this function, the optimizer
    will settle on the S, phi, CRPIXx and CRPIXy which minimize the 6 residuals. Each residual is the difference between the forward-
    transformed pse coordinate and the intermediate coordinate that should result.
    """

    S = params[0]
    phi = params[1]
    CRPIXx = params[2]
    CRPIXy = params[3]
    residualAx = (S*cos(phi)*(pseAx-CRPIXx) - S*sin(phi)*(pseAy-CRPIXy)) - intrmAx
    residualAy = (S*sin(phi)*(pseAx-CRPIXx) + S*cos(phi)*(pseAy-CRPIXy)) - intrmAy
    residualBx = (S*cos(phi)*(pseBx-CRPIXx) - S*sin(phi)*(pseBy-CRPIXy)) - intrmBx
    residualBy = (S*sin(phi)*(pseBx-CRPIXx) + S*cos(phi)*(pseBy-CRPIXy)) - intrmBy
    residualCx = (S*cos(phi)*(pseCx-CRPIXx) - S*sin(phi)*(pseCy-CRPIXy)) - intrmCx
    residualCy = (S*sin(phi)*(pseCx-CRPIXx) + S*cos(phi)*(pseCy-CRPIXy)) - intrmCy
    return np.array([residualAx, residualAy, residualBx, residualBy, residualCx, residualCy])

cdef getTriangleData(double x1, double y1, double x2, double y2, double x3, double y3, triangle_datalist):

    """
    Given 6 coordinates (3 points), this function determines labels for the three points (A for
    the point with the largest vertex measure, B for the middle, and C for the smallest) and
    calculates the longest sidelength (BC) as well as the angle of the vector that points from B 
    to C (relative to the x-axis of the image). All of these geometric properties are stored in a
    10-long array that itself will be inserted into a triangle "database" to be accessed later.
    """

    cdef:
        double sidelength12
        double sidelength23
        double sidelength31
        double pointAx
        double pointAy
        double pointBx
        double pointBy
        double pointCx
        double pointCy
        double sidelengthAB
        double sidelengthBC
        double sidelengthCA
        double vertexA
        double vertexB
        double vertexC
        double fieldvectorangle

    sidelength12 = sqrt((x1-x2)**2+(y1-y2)**2)
    sidelength23 = sqrt((x2-x3)**2+(y2-y3)**2)
    sidelength31 = sqrt((x3-x1)**2+(y3-y1)**2)

    if sidelength12 < sidelength31 < sidelength23:
        pointAx = x1
        pointAy = y1
        pointBx = x2
        pointBy = y2
        pointCx = x3
        pointCy = y3
    elif sidelength31 < sidelength12 < sidelength23:
        pointAx = x1
        pointAy = y1
        pointBx = x3
        pointBy = y3
        pointCx = x2
        pointCy = y2
    elif sidelength12 < sidelength23 < sidelength31:
        pointAx = x2
        pointAy = y2
        pointBx = x1
        pointBy = y1
        pointCx = x3
        pointCy = y3
    elif sidelength23 < sidelength12 < sidelength31:
        pointAx = x2
        pointAy = y2
        pointBx = x3
        pointBy = y3
        pointCx = x1
        pointCy = y1
    elif sidelength31 < sidelength23 < sidelength12:
        pointAx = x3
        pointAy = y3
        pointBx = x1
        pointBy = y1
        pointCx = x2
        pointCy = y2
    elif sidelength23 < sidelength31 < sidelength12:
        pointAx = x3
        pointAy = y3
        pointBx = x2
        pointBy = y2
        pointCx = x1
        pointCy = y1

    sidelengthAB = sqrt((pointAx-pointBx)**2+(pointAy-pointBy)**2)
    sidelengthBC = sqrt((pointBx-pointCx)**2+(pointBy-pointCy)**2)
    sidelengthCA = sqrt((pointCx-pointAx)**2+(pointCy-pointAy)**2)
    vertexA = acos((sidelengthAB**2+sidelengthCA**2-sidelengthBC**2)/(2*sidelengthAB*sidelengthCA))
    vertexB = acos((sidelengthAB**2+sidelengthBC**2-sidelengthCA**2)/(2*sidelengthAB*sidelengthBC))
    vertexC = acos((sidelengthCA**2+sidelengthBC**2-sidelengthAB**2)/(2*sidelengthCA*sidelengthBC))
    fieldvectorX = pointCx-pointBx
    fieldvectorY = pointCy-pointBy

    triangle_datalist[0] = pointAx
    triangle_datalist[1] = pointAy
    triangle_datalist[2] = pointBx
    triangle_datalist[3] = pointBy
    triangle_datalist[4] = pointCx
    triangle_datalist[5] = pointCy
    triangle_datalist[6] = vertexB
    triangle_datalist[7] = vertexC
    triangle_datalist[8] = sidelengthBC
    triangle_datalist[9] = fieldvectorX
    triangle_datalist[10] = fieldvectorY

cdef generateTriangles(int npts, double[:,:] coords_view, double[:,:] triangles_view):
    """
    The a,b,c triple-nested for-loop iterates over every possible 3-combination of points (intermediate or
    PSE points, depending on the function input). For each combination (triangle), getTriangleData calculates 
    some associated geometrical properties (metadata), and then an array of this metadata is placed in a 
    "repository" of triangle metadata arrays. This function is called twice in total, and will populate two 
    (intermediate and PSE) triangle repositories. The metadata stored inside both will be accessed at a later 
    point, when triangles are comparing against each other in the i,j double-nested for-loop.
    """

    cdef:
        Py_ssize_t triangleNo = 0
        Py_ssize_t a
        Py_ssize_t b
        Py_ssize_t c
        Py_ssize_t propertyNo
        double[:] triangledata_view = np.empty(11,dtype=np.double)

    triangleNo = 0
    for a in range(0, npts-2):
        for b in range(a+1, npts-1):
            for c in range(b+1, npts):
                getTriangleData(coords_view[a,0], coords_view[a,1], coords_view[b,0], coords_view[b,1], coords_view[c,0], coords_view[c,1], triangledata_view)
                for propertyNo in range(11):
                    triangles_view[triangleNo, propertyNo] = triangledata_view[propertyNo]
                triangleNo += 1

cdef int findInitialSolution(double[:,:] allintrmpoints_view, int num_catsources, double[:,:] pse_metadata_view, double[:,:] pse_metadata_inv_view, int num_psesources, int[:,:] srcindexmap_initial_view, int npts, int img_xmax, int img_ymax, double scale, double scalebnds, object rotation, object rotationbnds, double vertextol, int minmatches, int kerneldiam, double[:] initial_solution_view, debug_report, filepath, int verbosity, bint debug):
    """
    Finds the initial solution. First, all possible triangles of PSE points and all possible triangles of intermediate points
    are constructed. Then a loop iterates through both sets of triangles, looking at one from each set at a time. If two triangles
    are similar, this indicates that there is a unique scale, rotation, and reference point (the "initial solution"), which can be 
    used to transform one triangle into the other. At this point we use scipy.optimize.least_squares to solve for S, phi, CRPIXx 
    and CRPIXy, using the 3 pairs of corresponding points. Afterwords, we test our found solution (the parameters) by using the 
    inverse transformation. We take single intermediate points and look at where on the source index map they land when inverse 
    transformed. If they happen to land on a location that corresponds to a PSE source, i.e., not -1, then we increase a counter. 
    If, after having iterated through all intermediate coordinates, the count is above a certain threshold, we conclude that we
    have a solution. These parameters are then passed out of this function and will be used to create the refined solution.
    """

    cdef:
        int npts_intrm
        int npts_pse
    
    #It's possible (but rare) that the PSE output or the catalogue output may contain less than npts in total.
    #In that case, we have to use however many points are available.

    if num_catsources < npts:
        npts_intrm = num_catsources
    else:
        npts_intrm = npts
    
    if num_psesources < npts:
        npts_pse = num_psesources
    else:
        npts_pse = npts

    cdef:
        double[:,:] psepoints_view = pse_metadata_view[:npts_pse,:2]
        double[:,:] psepoints_inv_view = pse_metadata_inv_view[:npts_pse,:2]
        double[:,:] intrmpoints_view = allintrmpoints_view[:npts_intrm,:]
        Py_ssize_t i
        Py_ssize_t j
        Py_ssize_t k
        int nchoose3_pse = int(npts_pse*(npts_pse-1)*(npts_pse-2)/6)
        int nchoose3_intrm = int(npts_intrm*(npts_intrm-1)*(npts_intrm-2)/6)
        double S
        double S_guess
        double S_lb
        double S_ub
        bint user_rotation = True
        double phi
        double phi_guess
        double phi_lb
        double phi_ub
        double CRPIXx
        double CRPIXx_guess
        double CRPIXx_lb
        double CRPIXx_ub
        double CRPIXy
        double CRPIXy_guess
        double CRPIXy_lb
        double CRPIXy_ub
        double sidelengthtol
        int matches
        double[:,:] psetriangles_view = np.empty((nchoose3_pse,11),dtype=np.double)
        double[:,:] intrmtriangles_view = np.empty((nchoose3_intrm,11),dtype=np.double)
        double intrmlengthBC_lb
        double intrmlengthBC_ub
        double[:,:] invtransf_intrmtriangle_view = np.empty((3,2),dtype=np.double)
        double[:] invtransf_intrmpoint_view = np.empty(2,dtype=np.double)
        int resultcode = 0
        int prcnt = 0

    if debug:
        np.savetxt(debug_report/"psepoints.csv",np.asarray(psepoints_view), delimiter=",")
        np.savetxt(debug_report/"psepoints_inverted.csv",np.asarray(psepoints_inv_view), delimiter=",")
        np.savetxt(debug_report/"intrmpoints.csv",np.asarray(intrmpoints_view), delimiter=",")

    if verbosity == 2:
        psepoints_xrange = np.ptp(psepoints_view[:,0])
        intrmpoints_xrange = np.ptp(intrmpoints_view[:,0])
        approx_scale = intrmpoints_xrange/psepoints_xrange
        print("| | Approximate scale = {}".format(approx_scale))

    S_guess = scale
    S_lb = scale/(1+scalebnds)
    S_ub = scale*(1+scalebnds)
    if rotation is None and rotationbnds is None:
        user_rotation = False
        phi_guess = 0       ###these variables will be properly declared later
        phi_lb = 0
        phi_ub = 0
    elif rotation is not None and rotationbnds is not None:
        phi_guess = rotation
        phi_lb = rotation-rotationbnds-vertextol
        phi_ub = rotation+rotationbnds+vertextol
    elif rotation is None and rotationbnds is not None:
        phi_guess = 0
        phi_lb = 0-rotationbnds-vertextol
        phi_ub = 0+rotationbnds+vertextol
    elif rotation is not None and rotationbnds is None:
        phi_guess = rotation
        phi_lb = rotation-10*pi/180-vertextol
        phi_ub = rotation+10*pi/180+vertextol    
    CRPIXx_guess = np.mean(psepoints_inv_view[:,0])
    CRPIXy_guess = np.mean(psepoints_inv_view[:,1])
    CRPIXx_lb = 1
    CRPIXx_ub = img_xmax
    CRPIXy_lb = 1
    CRPIXy_ub = img_ymax

    if verbosity == 2:
        print("| | S_guess = {}".format(S_guess))
        print("| | S_lb = {}".format(S_lb))
        print("| | S_ub = {}".format(S_ub))
        if user_rotation is False:
            print("| | phi_guess = TBD in loop")
            print("| | phi_lb = TBD in loop")
            print("| | phi_ub = TBD in loop")
        else:
            print("| | phi_guess = {}".format(phi_guess))
            print("| | phi_lb = {}".format(phi_lb))
            print("| | phi_ub = {}".format(phi_ub))
        print("| | CRPIXx_guess = {}".format(CRPIXx_guess))
        print("| | CRPIXx_lb = {}".format(CRPIXx_lb))
        print("| | CRPIXx_ub = {}".format(CRPIXx_ub))
        print("| | CRPIXy_guess = {}".format(CRPIXy_guess))
        print("| | CRPIXy_lb = {}".format(CRPIXy_lb))
        print("| | CRPIXy_ub = {}".format(CRPIXy_ub))
    
    guess = np.array([S_guess, phi_guess, CRPIXx_guess, CRPIXy_guess])
    bnds = np.array([[S_lb,phi_lb,CRPIXx_lb,CRPIXy_lb],[S_ub,phi_ub,CRPIXx_ub,CRPIXy_ub]])

    if verbosity >= 1:
        print("| | (working with {} PSE sources and {} catalogue sources.)".format(npts_pse,npts_intrm))

    if debug and npts_intrm >= 10 and npts_pse >= 10:
        import matplotlib.pyplot as plt
        from matplotlib.colors import LogNorm
        from astropy.io import fits
        image_data = fits.getdata(filepath)
        fig = plt.figure(figsize=(15,7.5))

        axes1 = fig.add_subplot(121)
        axes1.set_title('10 brightest PSE and intermediate points')
        axes1.imshow(image_data, cmap="gray", norm=LogNorm())
        axes1.scatter(np.asarray(psepoints_view)[:10,0], np.asarray(psepoints_view)[:10,1], marker=".", c="blue")
        axes1.scatter(img_xmax-np.asarray(intrmpoints_view)[:10,0]/approx_scale-CRPIXx_guess, img_ymax-np.asarray(intrmpoints_view)[:10,1]/approx_scale-CRPIXy_guess, marker=".", c="red")
        
        axes2 = fig.add_subplot(122)
        axes2.set_title('{} brightest PSE and {} intermediate points'.format(npts_pse,npts_intrm))
        axes2.imshow(image_data, cmap="gray", norm=LogNorm())
        axes2.scatter(np.asarray(psepoints_view)[:,0], np.asarray(psepoints_view)[:,1], marker=".", c="blue")
        axes2.scatter(img_xmax-np.asarray(intrmpoints_view)[:,0]/approx_scale-CRPIXx_guess, img_ymax-np.asarray(intrmpoints_view)[:,1]/approx_scale-CRPIXy_guess, marker=".", c="red")

        dscrp = "PSE points (blue) and intermediate points (red) plotted overtop the image. Since the intermediate points are actually in radians, whereas the PSE points are in pixels, \nan 'approximate scale factor' has been guessed and used to put the intermediate coordinates roughly on the same scale as the PSE coordinates. The intermediate \ncoordinates center has also been shifted from (0,0) to the center of the PSE points. This allows the geometries to be compared visually."
        plt.figtext(0.5, 0.05, dscrp, ha="center", fontsize=9)
        plt.subplots_adjust(left=0.08, right=0.92, bottom=0.2, top=0.92, wspace=0.2, hspace=0.05)
        plt.savefig(debug_report/"shapecompare_initial.png")
        plt.show()

    if verbosity == 2:
        print("| | Constructing PSE triangles...")
    generateTriangles(npts_pse, psepoints_inv_view, psetriangles_view)
    if verbosity == 2:
        print("| | done")
        print("| | Constructing intermediate triangles...")
    generateTriangles(npts_intrm, intrmpoints_view, intrmtriangles_view)
    if verbosity == 2:
        print("| | done")

    for i in range(nchoose3_pse):
        if verbosity == 2:
            if i*100/nchoose3_pse > prcnt:
                print("| | i {}, {}%".format(i, prcnt))
                prcnt = i*100/nchoose3_pse
        psesrcindex_A = srcindexmap_initial_view[img_ymax-int(psetriangles_view[i,1])-1,img_xmax-int(psetriangles_view[i,0])-1]
        psesrcindex_B = srcindexmap_initial_view[img_ymax-int(psetriangles_view[i,3])-1,img_xmax-int(psetriangles_view[i,2])-1]
        psesrcindex_C = srcindexmap_initial_view[img_ymax-int(psetriangles_view[i,5])-1,img_xmax-int(psetriangles_view[i,4])-1]
        for j in range(nchoose3_intrm):
            if abs(psetriangles_view[i,6]-intrmtriangles_view[j,6]) < vertextol:
                if abs(psetriangles_view[i,7]-intrmtriangles_view[j,7]) < vertextol:
                    if intrmtriangles_view[j,8] > S_lb*(psetriangles_view[i,8]-kerneldiam) and intrmtriangles_view[j,8] < S_ub*(psetriangles_view[i,8]+kerneldiam):
                        theta = atan2(psetriangles_view[i,9]*intrmtriangles_view[j,10] - psetriangles_view[i,10]*intrmtriangles_view[j,9], psetriangles_view[i,9]*intrmtriangles_view[j,9] + psetriangles_view[i,10]*intrmtriangles_view[j,10])
                        if user_rotation is False:
                            guess[1] = theta
                            bnds[0,1] = theta - vertextol
                            bnds[1,1] = theta + vertextol
                        else:
                            if theta < phi_lb or theta > phi_ub:
                                continue
                        optimizedparams = optimization.least_squares(fun=fitTrianglesToGetSphi, x0=guess, bounds=bnds, args=(psetriangles_view[i,0], psetriangles_view[i,1], psetriangles_view[i,2], psetriangles_view[i,3], psetriangles_view[i,4], psetriangles_view[i,5], intrmtriangles_view[j,0], intrmtriangles_view[j,1], intrmtriangles_view[j,2], intrmtriangles_view[j,3], intrmtriangles_view[j,4], intrmtriangles_view[j,5]))
                        S = optimizedparams.x[0]
                        phi = optimizedparams.x[1]
                        CRPIXx = optimizedparams.x[2]
                        CRPIXy = optimizedparams.x[3]
                        inverseTransformTriangleUsingSphi(S, phi, CRPIXx, CRPIXy, intrmtriangles_view[j,0], intrmtriangles_view[j,1], intrmtriangles_view[j,2], intrmtriangles_view[j,3], intrmtriangles_view[j,4], intrmtriangles_view[j,5], invtransf_intrmtriangle_view)
                        if 1 <= invtransf_intrmtriangle_view[0,0] <= img_xmax and 1 <= invtransf_intrmtriangle_view[0,1] <= img_ymax:
                            if 1 <= invtransf_intrmtriangle_view[1,0] <= img_xmax and 1 <= invtransf_intrmtriangle_view[1,1] <= img_ymax:
                                if 1 <= invtransf_intrmtriangle_view[2,0] <= img_xmax and 1 <= invtransf_intrmtriangle_view[2,1] <= img_ymax:
                                    if psesrcindex_A == srcindexmap_initial_view[img_ymax-int(invtransf_intrmtriangle_view[0,1])-1,img_xmax-int(invtransf_intrmtriangle_view[0,0])-1]:
                                        if psesrcindex_B == srcindexmap_initial_view[img_ymax-int(invtransf_intrmtriangle_view[1,1])-1,img_xmax-int(invtransf_intrmtriangle_view[1,0])-1]:
                                            if psesrcindex_C == srcindexmap_initial_view[img_ymax-int(invtransf_intrmtriangle_view[2,1])-1,img_xmax-int(invtransf_intrmtriangle_view[2,0])-1]:
                                                matches = 0
                                                if debug:
                                                    invtransf_xs = []
                                                    invtransf_ys = []
                                                    invtransf_match_xs = []
                                                    invtransf_match_ys = []
                                                for k in range(npts_intrm):
                                                    inverseTransformPointUsingSphi(S, phi, CRPIXx, CRPIXy, intrmpoints_view[k,0], intrmpoints_view[k,1], invtransf_intrmpoint_view)
                                                    if debug:
                                                        invtransf_xs.append(invtransf_intrmpoint_view[0])
                                                        invtransf_ys.append(invtransf_intrmpoint_view[1])
                                                    if 1 <= invtransf_intrmpoint_view[0] <= img_xmax and 1 <= invtransf_intrmpoint_view[1] <= img_ymax:
                                                        if srcindexmap_initial_view[img_ymax-int(invtransf_intrmpoint_view[1])-1,img_xmax-int(invtransf_intrmpoint_view[0])-1] != -1:
                                                            matches += 1
                                                            if debug:
                                                                invtransf_match_xs.append(invtransf_intrmpoint_view[0])
                                                                invtransf_match_ys.append(invtransf_intrmpoint_view[1])
                                                if matches >= minmatches:
                                                    initial_solution_view[0] = S
                                                    initial_solution_view[1] = phi
                                                    initial_solution_view[2] = CRPIXx
                                                    initial_solution_view[3] = CRPIXy

                                                    if verbosity >= 1:
                                                        print("| | Found {} matches.".format(matches))
                                                        print("| | Initial solution vector: {}".format(np.asarray(initial_solution_view)))

                                                    if verbosity == 2:
                                                        print("| | * Scale (arcsec/pixel): {}".format(S*3600*180/pi))
                                                        print("| | * Rotation (degrees): {}".format(phi*180/pi))
                                                        print("| | * CRPIX1: {}".format(CRPIXx))
                                                        print("| | * CRPIX2: {}".format(CRPIXy))

                                                    if debug:
                                                        import matplotlib.pyplot as plt
                                                        from matplotlib.colors import LogNorm
                                                        from astropy.io import fits

                                                        invtransf_xs = img_xmax-np.asarray(invtransf_xs)
                                                        invtransf_ys = img_ymax-np.asarray(invtransf_ys)
                                                        invtransf_match_xs = img_xmax-np.asarray(invtransf_match_xs)
                                                        invtransf_match_ys = img_ymax-np.asarray(invtransf_match_ys)
                                                        fig = plt.figure(figsize=(9.5,8))

                                                        axes = fig.add_subplot(111)
                                                        axes.imshow(image_data, cmap="gray", norm=LogNorm())
                                                        #axes.scatter(img_xmax-np.asarray(invtransf_match_xs), img_ymax-np.asarray(invtransf_match_ys), marker='o', color='white')
                                                        axes.scatter(psepoints_view[:,0], psepoints_view[:,1], marker="+", color='yellow')
                                                        axes.scatter(np.asarray(invtransf_xs), np.asarray(invtransf_ys), marker='.', color='fuchsia')
                                                        dscrp = "Plot of the inverse-transformed points (fuchsia) of {} intermediate points. The inverse \ntransform used here is made up of the parameters found in the initial solution. The \ninverse-transformed points that yield a match (i.e., those that land on an occupied kernel \nin the source index map) are highlighted with a white circle. The PSE points are in blue.".format(npts_intrm)
                                                        plt.title("Inverse transform - {} points - initial solution".format(npts_intrm))
                                                        plt.figtext(0.5, 0.05, dscrp, ha="center", fontsize=9)
                                                        plt.subplots_adjust(top=0.92, bottom=0.2, right=0.92, left=0.08)
                                                        plt.savefig(debug_report/"inversetrans_matches_initial_{}.png".format(npts_intrm))
                                                        plt.show()

                                                    resultcode = 1
                                                    return resultcode
    resultcode = 2
    return resultcode

@printEvent
def WCS(scale, scalebnds, rotation, rotationbnds, npts, nrefinepts, vertextol, allintrmpoints, catalogue_points, mean_catcoords, pse_metadata, pse_metadata_inv, matchdata, num_matches, srcindexmap_initial, srcindexmap_refine, img_xmax, img_ymax, minmatches, kerneldiam, num_psesources, num_catsources, headervals, wcsdiagnostics, debug_report, filepath, user_dir, filename_body, verbosity, debug):
    """
    """

    if debug >= 1:
        import matplotlib.pyplot as plt
        from matplotlib.colors import LogNorm
        from astropy.io import fits

    #For some reason, exceptions such as ZeroDivisionError (which are actually caused by the user
    #forcefully terminating with ctrl-c) are ignored in the nested for-loops, so we have to have 
    #resultcodes (kind of like exitcodes, but 0 means error) to catch the error.

    initial_solution = np.zeros(4)

    if verbosity >= 1:
        print("| Finding initial solution...")
    resultcode = findInitialSolution(allintrmpoints, num_catsources, pse_metadata, pse_metadata_inv, num_psesources, srcindexmap_initial, npts, img_xmax, img_ymax, scale, scalebnds, rotation, rotationbnds, vertextol, minmatches, kerneldiam, initial_solution, debug_report, filepath, verbosity, debug)
    if resultcode == 1:
        if verbosity >= 1:
            print("| done")
    elif resultcode == 2:
        if verbosity >= 1:
            print("| done")
        sys.exit("Could not find a solution that gave at least {} matches.".format(minmatches))
    elif resultcode == 0:
        sys.exit("EXIT: fastrometry interrupted while finding initial solution.")

    refined_solution = np.zeros(6)

    if verbosity >= 1:
        print("| Refining solution...")
    resultcode = refineSolution(allintrmpoints, num_catsources, pse_metadata, pse_metadata_inv, num_psesources, matchdata, num_matches, npts, nrefinepts, img_xmax, img_ymax, srcindexmap_refine, initial_solution, refined_solution, debug_report, filepath, verbosity, debug)
    if resultcode == 1:
        if verbosity >= 1:
            print("| done")
    elif resultcode == 2:
        if verbosity >= 1:
            print("| | Cannot refine solution; no more sources available.")
            print("| done")
    elif resultcode == 0:
        sys.exit("EXIT: fastrometry interrupted while refining solution.")

    wcs_diagnostics = np.zeros(14)
    matches = num_matches[0]

    if verbosity >= 1:
        print("| Calculating WCS diagnostics...")
    calculateWCSdiagnostics(img_xmax, img_ymax, refined_solution, matchdata, matches, num_catsources, catalogue_points, mean_catcoords, wcs_diagnostics, debug_report, debug)
    if verbosity >= 1:
        print("| done")

    if verbosity >= 1:
        print("| Constructing keywords...")
    CTYPE1 = 'RA---TAN'
    CTYPE2 = 'DEC--TAN'
    CRPIX1 = refined_solution[4]                    #pixels
    CRPIX2 = refined_solution[5]                    #pixels
    CRVAL1 = mean_catcoords[0]*180/pi               #degrees
    CRVAL2 = mean_catcoords[1]*180/pi               #degrees
    CD1_1 = refined_solution[0]*180/pi              #degrees/pixel
    CD1_2 = refined_solution[1]*180/pi              #degrees/pixel
    CD2_1 = refined_solution[2]*180/pi              #degrees/pixel
    CD2_2 = refined_solution[3]*180/pi              #degrees/pixel
    CDELT1 = sqrt(CD1_1*CD1_1+CD1_2*CD1_2)*3600     #arcseconds/pixel
    CDELT2 = sqrt(CD2_1*CD2_1+CD2_2*CD2_2)*3600     #arcseconds/pixel
    CROTA1 = atan2(CD1_2,-CD1_1)*180/pi             #degrees
    CROTA2 = atan2(-CD2_1,-CD2_2)*180/pi            #degrees
    CCVALD1 = wcs_diagnostics[0]*180/pi             #degrees
    CCVALD2 = wcs_diagnostics[1]*180/pi             #degrees    
    CCVALS1_h = wcs_diagnostics[2]                  #hours
    CCVALS1_m = wcs_diagnostics[3]                  #minutes
    CCVALS1_s = wcs_diagnostics[4]                  #seconds
    CCVALS2_h = wcs_diagnostics[5]                  #hours
    CCVALS2_m = wcs_diagnostics[6]                  #minutes
    CCVALS2_s = wcs_diagnostics[7]                  #seconds
    CVAL1RM = wcs_diagnostics[8]                    #arcseconds
    CVAL1RS = wcs_diagnostics[9]                    #arcseconds
    CVAL2RM = wcs_diagnostics[10]                   #arcseconds
    CVAL2RS = wcs_diagnostics[11]                   #arcseconds
    CVALRM = wcs_diagnostics[12]                    #arcseconds
    CVALRS = wcs_diagnostics[13]                    #arcseconds

    if verbosity >= 1:
        print("| | CTYPE1 = {}".format(CTYPE1))
        print("| | CTYPE2 = {}".format(CTYPE2))
        print("| | CRPIX1 = {}".format(CRPIX1))
        print("| | CRPIX2 = {}".format(CRPIX2))
        print("| | CRVAL1 = {}".format(CRVAL1))
        print("| | CRVAL2 = {}".format(CRVAL2))
        print("| | CD1_1 = {}".format(CD1_1))
        print("| | CD1_2 = {}".format(CD1_2))
        print("| | CD2_1 = {}".format(CD2_1))
        print("| | CD2_2 = {}".format(CD2_2))
        print("| | CDELT1 = {}".format(CDELT1))
        print("| | CDELT2 = {}".format(CDELT2))
        print("| | CROTA1 = {}".format(CROTA1))
        print("| | CROTA2 = {}".format(CROTA2))
        # ...
        print("| | CVALRM = {}".format(CVALRM))
        print("| | CVALRS = {}".format(CVALRS))
        
    headervals[0] = CRPIX1
    headervals[1] = CRPIX2
    headervals[2] = CRVAL1
    headervals[3] = CRVAL2
    headervals[4] = CD1_1
    headervals[5] = CD1_2
    headervals[6] = CD2_1
    headervals[7] = CD2_2
    headervals[8] = CDELT1
    headervals[9] = CDELT2
    headervals[10] = CROTA1
    headervals[11] = CROTA2
    headervals[12] = CCVALD1
    headervals[13] = CCVALD2
    headervals[14] = CCVALS1_h
    headervals[15] = CCVALS1_m
    headervals[16] = CCVALS1_s
    headervals[17] = CCVALS2_h
    headervals[18] = CCVALS2_m
    headervals[19] = CCVALS2_s
    headervals[20] = CVAL1RM
    headervals[21] = CVAL1RS
    headervals[22] = CVAL2RM
    headervals[23] = CVAL2RS
    headervals[24] = CVALRM
    headervals[25] = CVALRS

    if verbosity >= 1:
        print("| done")